<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="https://ui-testing.academy/feed.xml" rel="self" type="application/atom+xml" /><link href="https://ui-testing.academy/" rel="alternate" type="text/html" hreflang="en" /><updated>2020-09-20T19:02:47+00:00</updated><id>https://ui-testing.academy/feed.xml</id><title type="html">UI Testing Academy</title><subtitle>UI Testing related content</subtitle><author><name>Alex Zhukovich</name></author><entry><title type="html">Never use sleep in test code</title><link href="https://ui-testing.academy/general/good-practices/never-use-sleep-in-test-code/" rel="alternate" type="text/html" title="Never use sleep in test code" /><published>2020-09-20T00:00:00+00:00</published><updated>2020-09-20T00:00:00+00:00</updated><id>https://ui-testing.academy/general/good-practices/never-use-sleep-in-test-code</id><content type="html" xml:base="https://ui-testing.academy/general/good-practices/never-use-sleep-in-test-code/">&lt;p&gt;Almost every application performs long-running operations, and automated UI test cases should wait until this operation is finished. Often we should wait in the following scenarios:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;interaction with the back-end&lt;/li&gt;
  &lt;li&gt;interaction with the database (especially when we load a lot of data)&lt;/li&gt;
  &lt;li&gt;complicated calculations (plan a route to a destination in navigation applications)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Different frameworks provide solutions for such operations. However, you can often find &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sleep&lt;/code&gt; operations in test code, which is usually a feature of the language and not one of the testing framework’s approaches.&lt;/p&gt;

&lt;p&gt;The main problem of such solutions is that the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sleep&lt;/code&gt; method will wait for a certain amount of time, and very often, the long-running operation can finish faster. In this situation, we are wasting a lot of time because of a long timeout in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sleep&lt;/code&gt; operation. When we have many test cases, we can reduce execution a lot by replacing the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sleep&lt;/code&gt; method with an alternative from the testing framework.&lt;/p&gt;

&lt;p&gt;Let’s take a look at alternatives that we can use for replacing &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sleep&lt;/code&gt; methods. Almost all solutions from different frameworks work in the following ways:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;checking condition multiple times until timeout is over&lt;/li&gt;
  &lt;li&gt;integrating test framework to application&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;checking-condition-multiple-times-until-timeout-is-over&quot;&gt;Checking condition multiple times until timeout is over&lt;/h2&gt;
&lt;p&gt;A typical implementation of the wait method appears in different frameworks, like UiAutomator (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait&lt;/code&gt;), Appium (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;waitForElement&lt;/code&gt;), Espresso (custom &lt;img src=&quot;https://developer.android.com/training/testing/espresso/idling-resource&quot; alt=&quot;Idling Resource&quot; /&gt;). This approach’s main idea is to check the condition more than once until timeout is over. Let’s imagine that we have a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait&lt;/code&gt; function with a timeout for 3 seconds, and we will check the condition every second. It means that this function can be done after 1, 2, or 3 seconds, and we can save a lot of time if this function takes more than 1 second for many test cases.&lt;/p&gt;

&lt;h2 id=&quot;integrating-test-framework-to-application&quot;&gt;Integrating test framework to application&lt;/h2&gt;
&lt;p&gt;Sometimes we can face a different approach, when we have to integrate a test framework inside the application. In this case, when the long-running operation starts, we tell the testing framework that the test case should wait. When the process is finished, we provide information to the framework that the test case can be continued — however, the main problem of this approach that our application is connected with a specific test framework. It can complicate migration to a new framework in the future, and you should always synchronize application code with test code.&lt;/p&gt;

&lt;p&gt;As you can see, we have more efficient approaches for replacing &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sleep&lt;/code&gt; in the test code, and reduce execution time. I recommend you verify conditions multiple times and don’t wait until the timeout is over.&lt;/p&gt;

&lt;p&gt;Note: Many frameworks already have such functions.&lt;/p&gt;</content><author><name>alex_zhukovich</name></author><summary type="html">Almost every application performs long-running operations, and automated UI test cases should wait until this operation is finished. Often we should wait in the following scenarios: interaction with the back-end interaction with the database (especially when we load a lot of data) complicated calculations (plan a route to a destination in navigation applications)</summary></entry><entry><title type="html">Separate your tests from the test automation framework</title><link href="https://ui-testing.academy/general/good-practices/separate-your-tests-from-the-test-automation-framework/" rel="alternate" type="text/html" title="Separate your tests from the test automation framework" /><published>2020-09-19T00:00:00+00:00</published><updated>2020-09-19T00:00:00+00:00</updated><id>https://ui-testing.academy/general/good-practices/separate-your-tests-from-the-test-automation-framework</id><content type="html" xml:base="https://ui-testing.academy/general/good-practices/separate-your-tests-from-the-test-automation-framework/">&lt;p&gt;The testing framework has a significant impact on the test cases in a project because each framework has its own approach for handling similar situations and issues. Even if you are happy with the framework, chances are that you will change it in the future.&lt;/p&gt;

&lt;p&gt;One of the main problems of migration from one framework to another is updating many test cases. When the project is big, you may face yourself adjusting many tests, and this may be time-consuming. The solution for the issue is to introduce abstraction and separate test cases from the testing framework.&lt;/p&gt;

&lt;p&gt;Let’s take a look at an example of a test case with the Espresso framework, which does the following actions:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Enter email address&lt;/li&gt;
  &lt;li&gt;Enter empty password&lt;/li&gt;
  &lt;li&gt;Check that the “Password is blank” error message is displayed&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Test&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;shouldDisplayErrorWhenPasswordIsBlank&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;email&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;test-account@alexzh.com&quot;&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;password&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;

   &lt;span class=&quot;c1&quot;&gt;// enter email&lt;/span&gt;
   &lt;span class=&quot;nf&quot;&gt;onView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;withId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;emailEditText&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;perform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;replaceText&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;email&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

   &lt;span class=&quot;c1&quot;&gt;// enter password&lt;/span&gt;
   &lt;span class=&quot;nf&quot;&gt;onView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;withId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;passwordEditText&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;perform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;replaceText&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;password&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

   &lt;span class=&quot;c1&quot;&gt;// press login button&lt;/span&gt;
   &lt;span class=&quot;nf&quot;&gt;onView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;withId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loginButton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;perform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;click&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;

   &lt;span class=&quot;c1&quot;&gt;// verification of error message&lt;/span&gt;
   &lt;span class=&quot;nf&quot;&gt;onView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;withText&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Password is blank&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;check&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;matches&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;isDisplayed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So, let’s try to make the code of the test case framework-independent by extracting base operations (enter text, click on the view, etc.) to functions:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;enterText&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;viewId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;onView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;withId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;viewId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;perform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;replaceText&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;clickOnView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;viewId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;onView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;withId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;viewId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;perform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;click&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hasText&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;onView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;withText&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;check&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;matches&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;isDisplayed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;After that, we can update our test case:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Test&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;shouldDisplayErrorWhenPasswordIsBlank&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;nf&quot;&gt;enterText&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;emailEditText&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;email&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
   &lt;span class=&quot;nf&quot;&gt;enterText&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;passwordEditText&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;password&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
   &lt;span class=&quot;nf&quot;&gt;clickOnView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loginButton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
   
   &lt;span class=&quot;nf&quot;&gt;hasText&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Password is blank&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/separate-tests-from-test-automation-framework/framework-independence.svg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Note: We can apply more advanced techniques for separating test code from the testing framework, like the PageObject pattern.&lt;/p&gt;

&lt;p&gt;The additional abstraction level allows you to save a lot of time during switching one technology to another one because, in this case, we only need to update the framework-dependent layer, and the test cases will not be subject to changes.&lt;/p&gt;</content><author><name>alex_zhukovich</name></author><summary type="html">The testing framework has a significant impact on the test cases in a project because each framework has its own approach for handling similar situations and issues. Even if you are happy with the framework, chances are that you will change it in the future.</summary></entry><entry><title type="html">Naming conventions for test cases</title><link href="https://ui-testing.academy/general/naming/naming-conventions-for-test-cases/" rel="alternate" type="text/html" title="Naming conventions for test cases" /><published>2020-09-06T00:00:00+00:00</published><updated>2020-09-06T00:00:00+00:00</updated><id>https://ui-testing.academy/general/naming/naming-conventions-for-test-cases</id><content type="html" xml:base="https://ui-testing.academy/general/naming/naming-conventions-for-test-cases/">&lt;p&gt;A name is an essential part of a test suite and each test scenario. When analyzing test reports, all you see are the names of the test cases. The right name of the test case provides information about the scenario, and often, it’s enough information for understanding the main idea.&lt;/p&gt;

&lt;p&gt;Many naming conventions can be applied to test cases.&lt;/p&gt;

&lt;p&gt;Note: Some runtime environments allow you to use space &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot; &quot;&lt;/code&gt; as a separator inside test names; in other cases, one of the most popular options is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;_&quot;&lt;/code&gt;. Example:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;should_showInvalidAuthenticationMessage_when_passwordIsInvalid
// or
should show authentication message when password is invalid
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Most used naming conventions for test cases:&lt;/p&gt;
&lt;h2 id=&quot;feature-which-will-be-tested&quot;&gt;Feature which will be tested&lt;/h2&gt;
&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;success_to_paid_for_order&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;fail_to_login_if_account_is_invalid&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;fail_to_apply_invalid_voucher&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;action-state-under-test-expected-behavior&quot;&gt;[Action] [State under test] [Expected behavior]&lt;/h2&gt;
&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;pay_validAccount_openSuccessScreen&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;login_invalidAccount_showInvalidUserMessage&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;addVoucher_invalidVoucher_showInvalidVoucherMessage&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;action-expected-behavior-state-under-test&quot;&gt;[Action] [Expected behavior] [State under test]&lt;/h2&gt;
&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;pay_openSuccessScreen_when_AccountIsValid&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;login_showInvalidUserMessage_when_AccountIsInvalid&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;addVoucher_showInvalidVoucherMessage_when_VoucherIsInvalid&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;should-expected-behavior-when-state-under-test&quot;&gt;Should [Expected behavior] When [State under test]&lt;/h2&gt;
&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;should_openSuccessScreen_when_userPayWithValidAccount&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;should_showInvalidUserMessage_when_loginWithInvalidAccount&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;should_showInvalidVoucherMessage_when_userAddInvalidVoucher&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;given-preconditions-when-state-under-test-then-expected-behavior&quot;&gt;Given [Preconditions] When [State under test] Then [Expected behavior]&lt;/h2&gt;
&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;given_userIsAuthenticated_when_accountNumberIsValidToPay_then_openSuccessScreen&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;given_userIsNotAuthenticated_when_invalidAccountToLogin_then_showInvalidVoucherMessage&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;given_userIsAuthenticated_when_addInvalidVoucher_then_showInvalidVoucherMessage&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>alex_zhukovich</name></author><summary type="html">A name is an essential part of a test suite and each test scenario. When analyzing test reports, all you see are the names of the test cases. The right name of the test case provides information about the scenario, and often, it’s enough information for understanding the main idea.</summary></entry><entry><title type="html">Approaches of UI testing</title><link href="https://ui-testing.academy/general/ui-testing/approaches-of-ui-testing/" rel="alternate" type="text/html" title="Approaches of UI testing" /><published>2020-09-06T00:00:00+00:00</published><updated>2020-09-06T00:00:00+00:00</updated><id>https://ui-testing.academy/general/ui-testing/approaches-of-ui-testing</id><content type="html" xml:base="https://ui-testing.academy/general/ui-testing/approaches-of-ui-testing/">&lt;p&gt;UI Testing can be done in the following ways:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Manual testing&lt;/li&gt;
  &lt;li&gt;Record and replay testing&lt;/li&gt;
  &lt;li&gt;Model-based testing&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Manual testing&lt;/strong&gt; is a type of software testing in which a tester performs actions for interaction with applications to check whether the software product is functioning correctly and meets all requirements. All test cases are executed manually without using any automated tools.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Pros
    &lt;ul&gt;
      &lt;li&gt;Does not require programming or automation knowledge&lt;/li&gt;
      &lt;li&gt;Helps to find critical bugs in the application&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Cons
    &lt;ul&gt;
      &lt;li&gt;It is a time-consuming approach&lt;/li&gt;
      &lt;li&gt;Quality depends on the capabilities of the tester/testing team, the quality of the requirements and the timeframe.&lt;/li&gt;
      &lt;li&gt;Usually, all test cases cannot be covered because of the size of the application or the timeframe.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Record and Replay&lt;/strong&gt; testing is a type of software testing in which a human record set of actions with automation tools and later on, these steps can be reproduced. Future runs can use various data sets for test cases.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Pros
    &lt;ul&gt;
      &lt;li&gt;Does not require programming and automation knowledge&lt;/li&gt;
      &lt;li&gt;Can be used as a transition tool from manual to automation testing approach&lt;/li&gt;
      &lt;li&gt;Can be used as an educational tool for learning the testing framework&lt;/li&gt;
      &lt;li&gt;Can be used as a tool for generating test cases before refactoring internal implementations&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Cons
    &lt;ul&gt;
      &lt;li&gt;Recorded test cases can be broken after minor changes in the application’s behavior, and often test cases should be recorded from the very beginning&lt;/li&gt;
      &lt;li&gt;Recorded test cases can be broken after network speed changes because such tools usually record a “waiting time”&lt;/li&gt;
      &lt;li&gt;Sometimes such tools generate unreadable and unmaintainable code, like Espresso Test Recorder&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Model-based testing&lt;/strong&gt; is a type of software testing in which a model of the software product will be created initially. The model is a description of system behavior. Usually, such models help to fully understand an application or feature that simplifies creating efficient test cases that can be automated.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Pros
    &lt;ul&gt;
      &lt;li&gt;Allows creating highly efficient test cases&lt;/li&gt;
      &lt;li&gt;Helps achieve high test coverage&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Cons
    &lt;ul&gt;
      &lt;li&gt;Requires programming skills&lt;/li&gt;
      &lt;li&gt;It requires more time to implement the test suite&lt;/li&gt;
      &lt;li&gt;The detailed model should be created before creating test cases&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>alex_zhukovich</name></author><summary type="html">UI Testing can be done in the following ways: Manual testing Record and replay testing Model-based testing</summary></entry><entry><title type="html">All test cases should be independent</title><link href="https://ui-testing.academy/general/good-practices/all-test-cases-should-be-independent/" rel="alternate" type="text/html" title="All test cases should be independent" /><published>2020-09-06T00:00:00+00:00</published><updated>2020-09-06T00:00:00+00:00</updated><id>https://ui-testing.academy/general/good-practices/all-test-cases-should-be-independent</id><content type="html" xml:base="https://ui-testing.academy/general/good-practices/all-test-cases-should-be-independent/">&lt;p&gt;A test case checks that part of the application works according to requirements. When we have a situation where one test case depends on the other one, we may see unexpected behavior in some test cases because of the following reasons:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;test cases may be executed in random sequence; in this case, some test cases could fail because of the incorrect initial state of the application or environment&lt;/li&gt;
  &lt;li&gt;failing one test could cause another test to fail too&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Many testing frameworks have a way to execute methods before and after the test case. In the case of JUnit 5, we can annotate methods with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@BeforeEach&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@AfterEach&lt;/code&gt; methods.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SuperImportantTestSuite&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

   &lt;span class=&quot;nd&quot;&gt;@BeforeEach&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setUp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// set up data before each test case&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; 

   &lt;span class=&quot;nd&quot;&gt;@Test&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;importantTestCase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;


   &lt;span class=&quot;nd&quot;&gt;@Test&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;superImportantTestCase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

   &lt;span class=&quot;nd&quot;&gt;@AfterEach&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;tearDown&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// clean up data after each test case&lt;/span&gt;
      &lt;span class=&quot;nf&quot;&gt;clearDatabase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Using methods with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@BeforeEach&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@AfterEach&lt;/code&gt; annotations from JUnit 5, or similar functionalities from other frameworks we can make our test cases independent. So, we can clean up data before or after each test scenario. In this case, every test case will start from the same state. In this example, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;importantTestCase&lt;/code&gt; and the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;superImportantTestCase&lt;/code&gt; will start with an empty database.&lt;/p&gt;</content><author><name>alex_zhukovich</name></author><summary type="html">A test case checks that part of the application works according to requirements. When we have a situation where one test case depends on the other one, we may see unexpected behavior in some test cases because of the following reasons: test cases may be executed in random sequence; in this case, some test cases could fail because of the incorrect initial state of the application or environment failing one test could cause another test to fail too</summary></entry></feed>